name: Deploy API

on:
  workflow_dispatch:
    inputs:
      commit_sha:
        description: Commit to deploy
        required: true
      environment:
        description: Target environment (production or staging)
        required: true
        default: staging
      remote_path:
        description: Remote path (e.g., /home/<user>/apps/nodejs/api_salonbw). If empty, repo variables are used.
        required: false
        default: ''
      app_name:
        description: MyDevil app/domain name to restart (e.g., api.salon-bw.pl). If empty, repo variables are used.
        required: false
        default: ''

permissions:
  contents: read

jobs:
  deploy:
    name: Upload Backend API
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4
        with:
          ref: ${{ github.event.inputs.commit_sha }}

      - name: Setup Node
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: ${{ vars.NODE_VERSION || '22' }}

      - name: Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4
        with:
          version: ${{ vars.PNPM_VERSION || '10.14.0' }}
          run_install: false

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Resolve deploy destination
        id: dest
        shell: bash
        run: |
          ENV="${{ github.event.inputs.environment }}"
          INPUT_PATH="${{ github.event.inputs.remote_path }}"
          INPUT_APP="${{ github.event.inputs.app_name }}"
          REMOTE_PATH="$INPUT_PATH"
          APP_NAME="$INPUT_APP"

          if [ -z "$REMOTE_PATH" ]; then
            if [ "$ENV" = "production" ] && [ -n "${{ vars.MYDEVIL_API_REMOTE_PATH_PRODUCTION }}" ]; then
              REMOTE_PATH="${{ vars.MYDEVIL_API_REMOTE_PATH_PRODUCTION }}"
            elif [ "$ENV" = "staging" ] && [ -n "${{ vars.MYDEVIL_API_REMOTE_PATH_STAGING }}" ]; then
              REMOTE_PATH="${{ vars.MYDEVIL_API_REMOTE_PATH_STAGING }}"
            fi
          fi

          if [ -z "$APP_NAME" ]; then
            if [ "$ENV" = "production" ] && [ -n "${{ vars.MYDEVIL_API_APP_NAME_PRODUCTION }}" ]; then
              APP_NAME="${{ vars.MYDEVIL_API_APP_NAME_PRODUCTION }}"
            elif [ "$ENV" = "staging" ] && [ -n "${{ vars.MYDEVIL_API_APP_NAME_STAGING }}" ]; then
              APP_NAME="${{ vars.MYDEVIL_API_APP_NAME_STAGING }}"
            fi
          fi

          if [ -z "$REMOTE_PATH" ] || [ -z "$APP_NAME" ]; then
            echo "::error::remote_path/app_name not provided and no repository variable fallback found" >&2
            exit 1
          fi
          echo "remote_path=$REMOTE_PATH" >> "$GITHUB_OUTPUT"
          echo "app_name=$APP_NAME" >> "$GITHUB_OUTPUT"

      - name: Validate resolved destination
        shell: bash
        run: |
          set -euo pipefail
          REMOTE_PATH='${{ steps.dest.outputs.remote_path }}'
          APP_NAME='${{ steps.dest.outputs.app_name }}'
          if ! [[ "$REMOTE_PATH" =~ ^[A-Za-z0-9_./-]+$ ]]; then echo "::error::Invalid remote_path"; exit 1; fi
          if ! [[ "$APP_NAME" =~ ^[A-Za-z0-9._-]+$ ]]; then echo "::error::Invalid app_name"; exit 1; fi

      - name: Build backend
        run: pnpm --filter salonbw-backend build

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          KEY_CONTENT="${MYDEVIL_SSH_KEY:-$SSH_PRIVATE_KEY}"
          if printf "%s" "$KEY_CONTENT" | grep -q -- "-----BEGIN "; then
            printf "%s" "$KEY_CONTENT" | tr -d '\r' > ~/.ssh/mydevil
          else
            printf "%s" "$KEY_CONTENT" | tr -d '\r' | base64 -d > ~/.ssh/mydevil || printf "%s" "$KEY_CONTENT" | tr -d '\r' > ~/.ssh/mydevil
          fi
          chmod 600 ~/.ssh/mydevil
          eval "$(ssh-agent -s)"
          ssh-add ~/.ssh/mydevil
          if [ -n "$MYDEVIL_KNOWN_HOSTS" ]; then
            printf "%s\n" "$MYDEVIL_KNOWN_HOSTS" > ~/.ssh/known_hosts
          else
            ssh-keyscan -H "$MYDEVIL_SSH_HOST" >> ~/.ssh/known_hosts
          fi
        env:
          MYDEVIL_SSH_HOST: ${{ secrets.MYDEVIL_SSH_HOST }}
          MYDEVIL_SSH_KEY: ${{ secrets.MYDEVIL_SSH_KEY }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          MYDEVIL_KNOWN_HOSTS: ${{ secrets.MYDEVIL_KNOWN_HOSTS }}

      - name: Upload backend bundle
        run: |
          set -euo pipefail
          ARCHIVE="$(mktemp).tar.gz"
          tar -czf "$ARCHIVE" -C backend/salonbw-backend dist package.json package-lock.json app.js
          REMOTE_ARCHIVE="/tmp/salonbw-backend-${{ github.run_id }}-${{ github.run_attempt }}.tar.gz"
          scp -i ~/.ssh/mydevil -o IdentitiesOnly=yes "$ARCHIVE" \
            ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }}:"$REMOTE_ARCHIVE"
          ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }} <<'DEPLOY_CMDS'
          set -euo pipefail
          REMOTE_PATH="${{ steps.dest.outputs.remote_path }}"
          REMOTE_ARCHIVE="/tmp/salonbw-backend-${{ github.run_id }}-${{ github.run_attempt }}.tar.gz"
          mkdir -p "$REMOTE_PATH"
          rm -rf "$REMOTE_PATH/dist"
          tar -xzf "$REMOTE_ARCHIVE" -C "$REMOTE_PATH"
          rm -f "$REMOTE_ARCHIVE"
          DEPLOY_CMDS
          rm -f "$ARCHIVE"

      - name: Ensure remote .env (staging/prod)
        run: |
          ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes \
            ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }} \
            "REMOTE_PATH='${{ steps.dest.outputs.remote_path }}' \
            DB_USER='${{ secrets.MYDEVIL_DB_USER }}' \
            DB_PASS='${{ secrets.MYDEVIL_DB_PASSWORD }}' \
            DB_HOST='${{ secrets.MYDEVIL_PG_HOST }}' \
            DB_PORT='${{ secrets.MYDEVIL_PG_PORT }}' \
            DB_NAME='${{ secrets.MYDEVIL_DB_NAME }}' \
            JWT_SECRET='${{ secrets.JWT_SECRET }}' \
            JWT_REFRESH_SECRET='${{ secrets.JWT_REFRESH_SECRET }}' \
            bash -s" <<'REMOTE_CMDS'
          set -euo pipefail
          cd "$REMOTE_PATH"
          # Create .env if missing; update critical vars if provided
          [ -f .env ] || : > .env
          add_or_set() { key="$1"; val="${2:-}"; if [ -n "$val" ]; then \
            if grep -q "^$key=" .env 2>/dev/null; then sed -i.bak "s|^$key=.*|$key=$val|" .env; \
            else printf "%s=%s\n" "$key" "$val" >> .env; fi; fi; }
          if ! grep -q '^DATABASE_URL=' .env 2>/dev/null && [ -n "${DB_USER:-}" ]; then \
            add_or_set DATABASE_URL "postgresql://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}"; \
          fi
          add_or_set NODE_ENV production
          add_or_set JWT_SECRET "${JWT_SECRET:-}"
          add_or_set JWT_REFRESH_SECRET "${JWT_REFRESH_SECRET:-}"
          rm -f .env.bak || true
          REMOTE_CMDS

      - name: Install production dependencies
        run: |
          ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }} <<'REMOTE_CMDS'
          set -euo pipefail
          REMOTE_PATH="${{ steps.dest.outputs.remote_path }}"
          cd "$REMOTE_PATH"
          if command -v npm22 >/dev/null 2>&1; then
            npm22 ci --omit=dev
          else
            npm ci --omit=dev
          fi
          REMOTE_CMDS

      - name: Run DB migrations
        run: |
          ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }} <<'REMOTE_CMDS'
          set -euo pipefail
          REMOTE_PATH="${{ steps.dest.outputs.remote_path }}"
          cd "$REMOTE_PATH"
          # Nest compiles to dist/src by default; prefer that path
          if command -v node22 >/dev/null 2>&1; then
            node22 dist/src/migrate.js || node22 dist/migrate.js
          else
            node dist/src/migrate.js || node dist/migrate.js
          fi
          REMOTE_CMDS

      - name: Restart API app
        run: ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }} "devil www restart '${{ steps.dest.outputs.app_name }}'"

      - name: Post-deploy smoke checks
        run: python3 scripts/post_deploy_checks.py
        env:
          TARGET_HOST: ${{ steps.dest.outputs.app_name }}
          TARGET_SCHEME: https
          DEPLOY_TARGET: api
          SMOKE_EMAIL_TO: ${{ vars.SMOKE_EMAIL_TO || 'kontakt@salon-bw.pl' }}

      - name: Diagnostic: fetch health endpoints (on failure)
        if: failure()
        run: |
          echo "--- GET /health (headers + body) ---"
          curl -i -sS "https://${{ steps.dest.outputs.app_name }}/health" || true
          echo "--- GET /healthz (headers + body) ---"
          curl -i -sS "https://${{ steps.dest.outputs.app_name }}/healthz" || true

      - name: Collect remote logs on failure
        if: failure()
        run: |
          ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes \
            ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }} \
            "REMOTE_PATH='${{ steps.dest.outputs.remote_path }}' APP='${{ steps.dest.outputs.app_name }}' bash -s" <<'REMOTE_CMDS'
          set -euo pipefail
          echo "=== Remote directory ==="; ls -la "$REMOTE_PATH" || true
          echo "=== Recent .log files ==="
          (ls -1t "$REMOTE_PATH"/*.log 2>/dev/null || true; ls -1t "$REMOTE_PATH"/logs/*.log 2>/dev/null || true) | head -n 5 | while read -r f; do
            [ -f "$f" ] || continue
            echo "--- $f (last 200 lines) ---"; tail -n 200 "$f" || true
          done
          echo "=== .env keys ==="; [ -f "$REMOTE_PATH/.env" ] && (grep -E '^[A-Z0-9_]+=' "$REMOTE_PATH/.env" | sed 's/=.*$/=[hidden]/') || echo "(no .env)"
          REMOTE_CMDS
