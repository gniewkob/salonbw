name: Deploy (MyDevil)

on:
  workflow_dispatch:
    inputs:
      ref:
        description: Git ref (branch, tag, or SHA)
        required: true
        default: main
      target:
        description: What to deploy (public|dashboard|api)
        required: true
        default: public
      api_url:
        description: Public API URL used at build time (leave empty to use environment defaults)
        required: false
        default: ''
      remote_path:
        description: Remote path (e.g., /home/<user>/domains/<domain>/public_nodejs). If empty, repo variables will be used.
        required: false
        default: ''
      app_name:
        description: MyDevil app name for restart. If empty, repo variables will be used.
        required: false
        default: ''
      environment:
        description: GitHub environment (staging or production)
        required: true
        default: production

env:
  PNPM_VERSION: 10.14.0
  NODE_VERSION: '22'

jobs:
  deploy:
    name: Deploy ${{ github.event.inputs.target }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    concurrency:
      group: deploy-${{ github.event.inputs.target }}-${{ github.ref }}
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4
        with:
          ref: ${{ github.event.inputs.ref }}

      # Input validation intentionally omitted due to quoting issues in GitHub runner

      - name: Setup Node
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@41ff72655975bd51cab0327fa583b6e92b6d3061 # v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Resolve API URL
        if: ${{ github.event.inputs.target != 'api' }}
        id: api
        shell: bash
        run: |
          INPUT_API="${{ github.event.inputs.api_url }}"
          ENV="${{ github.event.inputs.environment }}"
          if [ -n "$INPUT_API" ]; then
            API_URL="$INPUT_API"
          elif [ "$ENV" = "production" ] && [ -n "${{ secrets.MYDEVIL_API_URL_PRODUCTION }}" ]; then
            API_URL="${{ secrets.MYDEVIL_API_URL_PRODUCTION }}"
          elif [ "$ENV" = "production" ]; then
            API_URL="https://api.salon-bw.pl"
          elif [ "$ENV" = "staging" ] && [ -n "${{ secrets.MYDEVIL_API_URL_STAGING }}" ]; then
            API_URL="${{ secrets.MYDEVIL_API_URL_STAGING }}"
          else
            API_URL="/api"
          fi
          echo "api_url=$API_URL" >> "$GITHUB_OUTPUT"

      - name: Resolve Proxy URL
        if: ${{ github.event.inputs.target != 'api' }}
        id: proxy
        shell: bash
        run: |
          ENV="${{ github.event.inputs.environment }}"
          PROXY_URL="https://api.salon-bw.pl"
          if [ "$ENV" = "production" ] && [ -n "${{ secrets.MYDEVIL_API_URL_PRODUCTION }}" ]; then
            PROXY_URL="${{ secrets.MYDEVIL_API_URL_PRODUCTION }}"
          elif [ "$ENV" = "staging" ] && [ -n "${{ secrets.MYDEVIL_API_PROXY_URL_STAGING }}" ]; then
            PROXY_URL="${{ secrets.MYDEVIL_API_PROXY_URL_STAGING }}"
          fi
          echo "proxy_url=$PROXY_URL" >> "$GITHUB_OUTPUT"

      - name: Resolve deploy destination
        id: dest
        shell: bash
        run: |
          TARGET="${{ github.event.inputs.target }}"
          ENV="${{ github.event.inputs.environment }}"
          INPUT_PATH="${{ github.event.inputs.remote_path }}"
          INPUT_APP="${{ github.event.inputs.app_name }}"
          REMOTE_PATH="$INPUT_PATH"
          APP_NAME="$INPUT_APP"

          if [ -z "$REMOTE_PATH" ]; then
            if [ "$TARGET" = "api" ]; then
              if [ "$ENV" = "production" ] && [ -n "${{ vars.MYDEVIL_API_REMOTE_PATH_PRODUCTION }}" ]; then
                REMOTE_PATH="${{ vars.MYDEVIL_API_REMOTE_PATH_PRODUCTION }}"
              elif [ "$ENV" = "staging" ] && [ -n "${{ vars.MYDEVIL_API_REMOTE_PATH_STAGING }}" ]; then
                REMOTE_PATH="${{ vars.MYDEVIL_API_REMOTE_PATH_STAGING }}"
              fi
            else
              if [ "$ENV" = "production" ] && [ -n "${{ vars.MYDEVIL_REMOTE_PATH_PRODUCTION }}" ]; then
                REMOTE_PATH="${{ vars.MYDEVIL_REMOTE_PATH_PRODUCTION }}"
              elif [ "$ENV" = "staging" ] && [ -n "${{ vars.MYDEVIL_REMOTE_PATH_STAGING }}" ]; then
                REMOTE_PATH="${{ vars.MYDEVIL_REMOTE_PATH_STAGING }}"
              fi
            fi
          fi

          if [ -z "$APP_NAME" ]; then
            if [ "$TARGET" = "api" ]; then
              if [ "$ENV" = "production" ] && [ -n "${{ vars.MYDEVIL_API_APP_NAME_PRODUCTION }}" ]; then
                APP_NAME="${{ vars.MYDEVIL_API_APP_NAME_PRODUCTION }}"
              elif [ "$ENV" = "staging" ] && [ -n "${{ vars.MYDEVIL_API_APP_NAME_STAGING }}" ]; then
                APP_NAME="${{ vars.MYDEVIL_API_APP_NAME_STAGING }}"
              fi
            else
              if [ "$ENV" = "production" ] && [ -n "${{ vars.MYDEVIL_APP_NAME_PRODUCTION }}" ]; then
                APP_NAME="${{ vars.MYDEVIL_APP_NAME_PRODUCTION }}"
              elif [ "$ENV" = "staging" ] && [ -n "${{ vars.MYDEVIL_APP_NAME_STAGING }}" ]; then
                APP_NAME="${{ vars.MYDEVIL_APP_NAME_STAGING }}"
              fi
            fi
          fi

          if [ -z "$REMOTE_PATH" ]; then
            echo "::error::remote_path not provided and no repository variable fallback found" >&2
            exit 1
          fi
          if [ -z "$APP_NAME" ]; then
            echo "::error::app_name not provided and no repository variable fallback found" >&2
            exit 1
          fi
          echo "remote_path=$REMOTE_PATH" >> "$GITHUB_OUTPUT"
          echo "app_name=$APP_NAME" >> "$GITHUB_OUTPUT"

      - name: Validate resolved destination
        shell: bash
        run: |
          set -euo pipefail
          REMOTE_PATH='${{ steps.dest.outputs.remote_path }}'
          APP_NAME='${{ steps.dest.outputs.app_name }}'
          if ! [[ "$REMOTE_PATH" =~ ^[A-Za-z0-9_./-]+$ ]]; then echo "::error::Invalid remote_path"; exit 1; fi
          if [ -n "$APP_NAME" ] && ! [[ "$APP_NAME" =~ ^[A-Za-z0-9._-]+$ ]]; then echo "::error::Invalid app_name"; exit 1; fi

      - name: Build frontend
        if: ${{ github.event.inputs.target != 'api' }}
        run: pnpm --filter frontend build
        env:
          # Embed API base URL resolved above (input > env-specific > fallback)
          NEXT_PUBLIC_API_URL: ${{ steps.api.outputs.api_url }}
          API_PROXY_URL: ${{ steps.proxy.outputs.proxy_url }}

      - name: Build backend
        if: ${{ github.event.inputs.target == 'api' }}
        run: pnpm --filter salonbw-backend build

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          KEY_CONTENT="${MYDEVIL_SSH_KEY:-$SSH_PRIVATE_KEY}"
          if printf "%s" "$KEY_CONTENT" | grep -q -e "-----BEGIN "; then
            printf "%s" "$KEY_CONTENT" | tr -d '\r' > ~/.ssh/mydevil
          else
            printf "%s" "$KEY_CONTENT" | tr -d '\r' | base64 -d > ~/.ssh/mydevil || printf "%s" "$KEY_CONTENT" | tr -d '\r' > ~/.ssh/mydevil
          fi
          chmod 600 ~/.ssh/mydevil
          eval "$(ssh-agent -s)"
          ssh-add ~/.ssh/mydevil
          if [ -n "$MYDEVIL_KNOWN_HOSTS" ]; then
            printf "%s\n" "$MYDEVIL_KNOWN_HOSTS" > ~/.ssh/known_hosts
          else
            ssh-keyscan -H "$MYDEVIL_SSH_HOST" >> ~/.ssh/known_hosts
          fi
        env:
          MYDEVIL_SSH_HOST: ${{ secrets.MYDEVIL_SSH_HOST }}
          MYDEVIL_SSH_KEY: ${{ secrets.MYDEVIL_SSH_KEY }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          MYDEVIL_KNOWN_HOSTS: ${{ secrets.MYDEVIL_KNOWN_HOSTS }}

      - name: Ensure remote directories exist (frontend)
        if: ${{ github.event.inputs.target != 'api' }}
        run: |
          ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }} "mkdir -p '${{ steps.dest.outputs.remote_path }}/.next/standalone' '${{ steps.dest.outputs.remote_path }}/.next/static' '${{ steps.dest.outputs.remote_path }}/public'"

      - name: Upload frontend bundle
        if: ${{ github.event.inputs.target != 'api' }}
        run: |
          rsync -az --delete \
            --exclude='.git' \
            -e "ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes" frontend/.next/standalone/ \
            ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }}:${{ steps.dest.outputs.remote_path }}/.next/standalone/
          rsync -az -e "ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes" --delete frontend/.next/static/ \
            ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }}:${{ steps.dest.outputs.remote_path }}/.next/static/
          rsync -az -e "ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes" --delete frontend/public/ \
            ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }}:${{ steps.dest.outputs.remote_path }}/public/
          rsync -az -e "ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes" frontend/app.js \
            ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }}:${{ steps.dest.outputs.remote_path }}/

      - name: Prepare standalone runtime (install prod deps)
        if: ${{ github.event.inputs.target != 'api' }}
        run: |
          ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }} "REMOTE_PATH='${{ steps.dest.outputs.remote_path }}' bash -s" <<'SSH'
          set -euo pipefail
          cd "${REMOTE_PATH}/.next/standalone"
          # Remove workspace:* deps that npm can't resolve
          node - <<'NODE'
          const fs=require('fs');
          const f='package.json';
          const pkg=JSON.parse(fs.readFileSync(f,'utf8'));
          for (const k of ['dependencies','devDependencies','optionalDependencies','peerDependencies']){
            const o=pkg[k]; if(!o) continue;
            for (const d of Object.keys(o)) { if (String(o[d]).startsWith('workspace:')) delete o[d]; }
          }
          fs.writeFileSync(f, JSON.stringify(pkg,null,2));
          NODE
          npm install --omit=dev --ignore-scripts
          # Ensure Next can find static assets relative to standalone distDir
          mkdir -p .next
          cd .next
          rm -rf static
          ln -s ../../.next/static static
          SSH

      - name: Upload backend bundle
        if: ${{ github.event.inputs.target == 'api' }}
        run: |
          rsync -az --delete \
            --exclude='.git' \
            -e "ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes" backend/salonbw-backend/dist/ \
            ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }}:${{ steps.dest.outputs.remote_path }}/dist/
          rsync -az -e "ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes" backend/salonbw-backend/package.json \
            ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }}:${{ steps.dest.outputs.remote_path }}/
          rsync -az -e "ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes" backend/salonbw-backend/app.js \
            ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }}:${{ steps.dest.outputs.remote_path }}/

      - name: Ensure remote .env (api)
        if: ${{ github.event.inputs.target == 'api' }}
        run: |
          ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes \
            ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }} \
            "REMOTE_PATH='${{ steps.dest.outputs.remote_path }}' \
            ENV='${{ github.event.inputs.environment }}' \
            DB_USER='${{ secrets.MYDEVIL_DB_USER }}' \
            DB_PASS='${{ secrets.MYDEVIL_DB_PASSWORD }}' \
            DB_HOST='${{ secrets.MYDEVIL_PG_HOST }}' \
            DB_PORT='${{ secrets.MYDEVIL_PG_PORT }}' \
            DB_NAME='${{ secrets.MYDEVIL_DB_NAME }}' \
            JWT_SECRET='${{ secrets.JWT_SECRET }}' \
            JWT_REFRESH_SECRET='${{ secrets.JWT_REFRESH_SECRET }}' \
            DB_URL='${{ secrets.DATABASE_URL }}' \
            WHATSAPP_LANG='${{ secrets.WHATSAPP_LANG }}' \
            SMTP_HOST='${{ secrets.SMTP_HOST }}' \
            SMTP_PORT='${{ secrets.SMTP_PORT }}' \
            SMTP_SECURE='${{ secrets.SMTP_SECURE }}' \
            SMTP_USER='${{ secrets.SMTP_USER }}' \
            SMTP_PASSWORD='${{ secrets.SMTP_PASSWORD }}' \
            SMTP_FROM='${{ secrets.SMTP_FROM }}' \
            NODE_ENV_VAL='${{ secrets.NODE_ENV }}' \
            PGHOST_VAL='${{ secrets.PGHOST }}' \
            PGPORT_VAL='${{ secrets.PGPORT }}' \
            PGUSER_VAL='${{ secrets.PGUSER }}' \
            PGPASSWORD_VAL='${{ secrets.PGPASSWORD }}' \
            PGDATABASE_VAL='${{ secrets.PGDATABASE }}' \
            bash -s" <<'REMOTE_CMDS'
          set -euo pipefail
          cd "$REMOTE_PATH"
          [ -f .env ] || : > .env
          add_or_set() { key="$1"; val="${2:-}"; if [ -n "$val" ]; then \
            esc=$(printf '%s' "$val" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g'); \
            if grep -q "^$key=" .env 2>/dev/null; then sed -i.bak "s|^$key=.*|$key=\"$esc\"|" .env; \
            else printf "%s=\"%s\"\n" "$key" "$esc" >> .env; fi; fi; }
          _PG_HOST="${DB_HOST:-}"; if [ -z "$_PG_HOST" ]; then _PG_HOST="pgsql0"; fi
          if command -v node22 >/dev/null 2>&1; then ENCCMD=node22; else ENCCMD=node; fi
          ENC_USER="$($ENCCMD -e 'process.stdout.write(encodeURIComponent(process.env.DB_USER||""))')"
          ENC_PASS="$($ENCCMD -e 'process.stdout.write(encodeURIComponent(process.env.DB_PASS||""))')"
          ENC_NAME="$($ENCCMD -e 'process.stdout.write(encodeURIComponent(process.env.DB_NAME||""))')"
          URL="postgresql://${ENC_USER}:${ENC_PASS}@${_PG_HOST}:${DB_PORT:-5432}/${ENC_NAME}"
          if [ "${ENV:-staging}" = "staging" ]; then
            if [ -n "${DB_USER:-}" ]; then add_or_set DATABASE_URL "$URL"; fi
          else
            if ! grep -q '^DATABASE_URL=' .env 2>/dev/null && [ -n "${DB_USER:-}" ]; then add_or_set DATABASE_URL "$URL"; fi
          fi
          # Override with explicit DATABASE_URL if provided
          add_or_set DATABASE_URL "${DB_URL:-}"
          add_or_set NODE_ENV production
          add_or_set JWT_SECRET "${JWT_SECRET:-}"
          add_or_set JWT_REFRESH_SECRET "${JWT_REFRESH_SECRET:-}"
          add_or_set WHATSAPP_LANG "${WHATSAPP_LANG:-}"
          add_or_set SMTP_HOST "${SMTP_HOST:-}"
          add_or_set SMTP_PORT "${SMTP_PORT:-}"
          add_or_set SMTP_SECURE "${SMTP_SECURE:-}"
          add_or_set SMTP_USER "${SMTP_USER:-}"
          add_or_set SMTP_PASSWORD "${SMTP_PASSWORD:-}"
          add_or_set SMTP_FROM "${SMTP_FROM:-}"
          add_or_set NODE_ENV "${NODE_ENV_VAL:-production}"
          add_or_set PGHOST "${PGHOST_VAL:-}"
          add_or_set PGPORT "${PGPORT_VAL:-}"
          add_or_set PGUSER "${PGUSER_VAL:-}"
          add_or_set PGPASSWORD "${PGPASSWORD_VAL:-}"
          add_or_set PGDATABASE "${PGDATABASE_VAL:-}"
          add_or_set PGHOST "${_PG_HOST}"
          add_or_set PGPORT "${DB_PORT:-5432}"
          add_or_set PGUSER "${DB_USER:-}"
          add_or_set PGPASSWORD "${DB_PASS:-}"
          add_or_set PGDATABASE "${DB_NAME:-}"
          rm -f .env.bak || true
          REMOTE_CMDS

      - name: Validate DB connectivity (api)
        if: ${{ github.event.inputs.target == 'api' }}
        run: |
          ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }} <<'REMOTE_CMDS'
          set -euo pipefail
          REMOTE_PATH='${{ steps.dest.outputs.remote_path }}'
          cd "$REMOTE_PATH"
          echo "Testing DB connectivity using DATABASE_URL..."
          if command -v node22 >/dev/null 2>&1; then NODECMD=node22; else NODECMD=node; fi
          "${NODECMD}" -e "require('dotenv').config();(async()=>{const {Client}=require('pg');const ssl=process.env.PGSSL==='1'?{rejectUnauthorized:false}:undefined;let cfg=null;if(process.env.DATABASE_URL){cfg={connectionString:process.env.DATABASE_URL,ssl};}else{cfg={host:process.env.PGHOST||process.env.DB_HOST||'pgsql0',port:Number(process.env.PGPORT||process.env.DB_PORT||5432),user:process.env.PGUSER||process.env.DB_USER,password:process.env.PGPASSWORD||process.env.DB_PASS,database:process.env.PGDATABASE||process.env.DB_NAME,ssl};}console.log('DB probe cfg',{host:cfg.host||'[url]',port:cfg.port||'[url]',user:cfg.user||'[url]',database:cfg.database||'[url]'});try{const c=new Client(cfg);await c.connect();const r=await c.query('SELECT 1 AS ok');console.log('DB OK',r.rows[0]);await c.end();}catch(e){console.error('DB FAIL',e&& (e.stack||e.message)||e);process.exit(3);}})()"
          REMOTE_CMDS

      - name: Run DB migrations (api)
        if: ${{ github.event.inputs.target == 'api' }}
        run: |
          ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }} <<'REMOTE_CMDS'
          set -euo pipefail
          REMOTE_PATH='${{ steps.dest.outputs.remote_path }}'
          cd "$REMOTE_PATH"
          if command -v node22 >/dev/null 2>&1; then
            node22 dist/src/migrate.js || node22 dist/migrate.js
          else
            node dist/src/migrate.js || node dist/migrate.js
          fi
          REMOTE_CMDS

      - name: Restart app (frontend)
        if: ${{ github.event.inputs.target != 'api' }}
        run: ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }} "devil www restart '${{ steps.dest.outputs.app_name }}'"

      - name: Restart app (backend)
        if: ${{ github.event.inputs.target == 'api' }}
        run: ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }} "devil www restart '${{ steps.dest.outputs.app_name }}'"

      - name: Smoke test (backend)
        if: ${{ github.event.inputs.target == 'api' }}
        run: python3 scripts/post_deploy_checks.py
        env:
          TARGET_HOST: ${{ steps.dest.outputs.app_name }}
          TARGET_SCHEME: https
          DEPLOY_TARGET: api
          SMOKE_EMAIL_TO: ${{ vars.SMOKE_EMAIL_TO || 'kontakt@salon-bw.pl' }}

      - name: Diagnostic: fetch health endpoints (on failure)
        if: ${{ github.event.inputs.target == 'api' && failure() }}
        run: |
          python3 - <<'PY'
          import ssl, sys, urllib.request
          host = "${{ steps.dest.outputs.app_name }}"
          ctx = ssl.create_default_context()
          for path in ("/health", "/healthz"):
              url = f"https://{host}{path}"
              print(f"--- GET {url} (headers + body) ---")
              req = urllib.request.Request(url=url, method="GET")
              try:
                  with urllib.request.urlopen(req, timeout=15, context=ctx) as resp:
                      print(f"HTTP/{resp.version/10:.1f} {resp.status}")
                      for k, v in resp.getheaders():
                          print(f"{k}: {v}")
                      print()
                      print(resp.read(512).decode("utf-8", errors="replace"))
              except Exception as exc:
                  print(f"ERROR: {exc}")
          PY

      - name: Collect remote logs on failure
        if: ${{ github.event.inputs.target == 'api' && failure() }}
        run: |
          ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes \
            ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }} \
            "REMOTE_PATH='${{ steps.dest.outputs.remote_path }}' APP='${{ steps.dest.outputs.app_name }}' bash -s" <<'REMOTE_CMDS'
          set -euo pipefail
          echo "=== Remote directory ==="; ls -la "$REMOTE_PATH" || true
          echo "=== Recent .log files ==="
          (ls -1t "$REMOTE_PATH"/*.log 2>/dev/null || true; ls -1t "$REMOTE_PATH"/logs/*.log 2>/dev/null || true) | head -n 5 | while read -r f; do
            [ -f "$f" ] || continue
            echo "--- $f (last 200 lines) ---"; tail -n 200 "$f" || true
          done
          echo "=== Searching user logs dir ==="
          if [ -d "$HOME/logs" ]; then
            find "$HOME/logs" -maxdepth 2 -type f -name "*${APP#*.}*error*.log" -o -name "*${APP}*error*.log" -o -name "*error*.log" 2>/dev/null | head -n 5 | while read -r f; do
              echo "--- $f (last 200 lines) ---"; tail -n 200 "$f" || true
            done
          fi
          echo "=== .env keys ==="; [ -f "$REMOTE_PATH/.env" ] && (grep -E '^[A-Z0-9_]+=' "$REMOTE_PATH/.env" | sed 's/=.*$/=[hidden]/') || echo "(no .env)"
          REMOTE_CMDS

      - name: Smoke test (frontend)
        if: ${{ github.event.inputs.target != 'api' }}
        shell: bash
        run: |
          set -euo pipefail
          BUILD_ID=$(ssh -i ~/.ssh/mydevil -o IdentitiesOnly=yes ${{ secrets.MYDEVIL_SSH_USER }}@${{ secrets.MYDEVIL_SSH_HOST }} "cat '${{ steps.dest.outputs.remote_path }}/.next/BUILD_ID'" )
          echo "BUILD_ID=$BUILD_ID"
          curl -fsS "https://${{ steps.dest.outputs.app_name }}/_next/static/${BUILD_ID}/_buildManifest.js" -I | sed -n '1,3p'
          curl -fsS "https://${{ steps.dest.outputs.app_name }}/_next/static/chunks/framework-070152267489c78d.js" -I | sed -n '1,3p'
          curl -fsS "https://${{ steps.dest.outputs.app_name }}/api/runtime" | head -c 200 && echo
